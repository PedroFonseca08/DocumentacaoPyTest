{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introdu\u00e7\u00e3o","text":"<p>O Pytest \u00e9 uma ferramenta de testes para Python que se destaca pela sua simplicidade e flexibilidade. Ele facilita a cria\u00e7\u00e3o e execu\u00e7\u00e3o de testes automatizados em diversos tipos de projetos, desde pequenos scripts at\u00e9 grandes aplica\u00e7\u00f5es.</p>"},{"location":"#beneficios-dos-testes","title":"Benef\u00edcios dos Testes","text":"<p>Os testes s\u00e3o fundamentais para garantir a qualidade e a confiabilidade de um software. Eles permitem identificar erros e bugs de forma antecipada, reduzindo os custos de manuten\u00e7\u00e3o e evitando problemas em produ\u00e7\u00e3o.</p> <ul> <li>Qualidade e Estabilidade: Testes garantem que o c\u00f3digo funciona conforme o esperado, mesmo ap\u00f3s modifica\u00e7\u00f5es.</li> <li>Facilidade de Manuten\u00e7\u00e3o: Com testes automatizados, \u00e9 poss\u00edvel refatorar o c\u00f3digo com seguran\u00e7a.</li> <li>Efici\u00eancia no Desenvolvimento: Detectar problemas cedo acelera o ciclo de desenvolvimento.</li> </ul> <p>Investir em testes aumenta a confian\u00e7a no software e melhora a experi\u00eancia do usu\u00e1rio final.</p>"},{"location":"#instalacao","title":"Instala\u00e7\u00e3o","text":"<p>Digite a seguinte linha de comando para realizar a instala\u00e7\u00e3o do Pytest:</p> <pre><code>pip install pytest\n</code></pre> <p>Verifique se a instala\u00e7\u00e3o do Pytest foi bem sucedida:</p> <pre><code>$ pytest --version\npytest 8.3.2\n</code></pre>"},{"location":"#criando-um-teste","title":"Criando um teste","text":"<p>Crie um arquivo test_simples.py com o seguinte c\u00f3digo:</p> python <pre><code>def function(x):\n    return x + 1\n\ndef test_answer():\n    assert function(3) == 5\n</code></pre> <p>Nota</p> <p>O Pytest permite que voc\u00ea use o assert padr\u00e3o do Python para verificar expectativas e valores em testes.</p> <p>Em seguida, execute o comando:</p> <pre><code>$ pytest\n=========================== test session starts ============================\nplatform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y\nrootdir: /home/sweet/project\ncollected 1 item\n\ntest_simples.py F                                                     [100%]\n\n================================= FAILURES =================================\n_______________________________ test_answer ________________________________\n\n    def test_answer():\n&gt;       assert function(3) == 5\nE       assert 4 == 5\nE        +  where 4 = function(3)\n\ntest_simples.py:6: AssertionError\n========================= short test summary info ==========================\nFAILED test_simples.py::test_answer - assert 4 == 5\n============================ 1 failed in 0.12s =============================\n</code></pre>"},{"location":"#verificando-excecao","title":"Verificando exce\u00e7\u00e3o","text":"<p>Use o auxiliar raises para verificar se um c\u00f3digo gera uma exce\u00e7\u00e3o:</p> <pre><code># test_sysexit.py\nimport pytest\n\n\ndef function():\n    raise SystemExit(1)\n\n\ndef test_meuTeste():\n    with pytest.raises(SystemExit):\n        function()\n</code></pre> <p>Executando o teste da fun\u00e7\u00e3o no modo quieto (\"-q\"): <pre><code>$ pytest -q test_sysexit.py\n.                                                                    [100%]\n1 passed in 0.12s\n</code></pre></p>"},{"location":"#agrupando-varios-testes-em-uma-classe","title":"Agrupando v\u00e1rios testes em uma classe","text":"<p>Depois de desenvolver v\u00e1rios testes, voc\u00ea pode querer agrup\u00e1-los em uma classe. O Pytest possiblita a cria\u00e7\u00e3o de uma classe contendo mais de um teste:</p> python <pre><code># test_classe.py\nclass TestClasse:\n    def test_um(self):\n        x = \"this\"\n        assert \"h\" in x\n\n    def test_dois(self):\n        x = \"hello\"\n        assert hasattr(x, \"check\")\n</code></pre> <p>Nota</p> <p>O PyTest segue conven\u00e7\u00f5es para descobrir testes em projetos Python:</p> <ol> <li>Se nenhum argumento for fornecido, a busca come\u00e7a no diret\u00f3rio atual ou em testpaths.</li> <li>Ele procura recursivamente por arquivos com padr\u00f5es test_.py ou _test.py.</li> <li>Dentro desses arquivos, coleta fun\u00e7\u00f5es e m\u00e9todos de teste prefixados com test_, seja fora de classes ou dentro de classes prefixadas com Test (sem m\u00e9todos init).</li> <li>Testes tamb\u00e9m podem ser descobertos por meio da heran\u00e7a de unittest.TestCase.</li> </ol> <p>Sa\u00edda: <pre><code>$ pytest -q test_class.py\n.F                                                                   [100%]\n================================= FAILURES =================================\n____________________________ TestClass.test_two ____________________________\n\nself = &lt;test_class.TestClass object at 0xdeadbeef0001&gt;\n\n    def test_two(self):\n        x = \"hello\"\n&gt;       assert hasattr(x, \"check\")\nE       Assertiumrror: assert False\nE        +  where False = hasattr('hello', 'check')\n\ntest_class.py:8: AssertionError\n===============dois======= short test summary info ==========================\nFAILED test_class.py::TestClass::test_two - AssertionError: assert False\n1 failed, 1 passed in 0.12s\n</code></pre></p>"},{"location":"#suporte-as-versoes-do-python","title":"Suporte \u00e0s vers\u00f5es do Python","text":"<p>Essa tabela exibe as vers\u00f5es do PyTest e as vers\u00f5es m\u00ednimas correspondentes do Python necess\u00e1rias para cada uma delas.</p> Vers\u00e3o do PyTest Vers\u00e3o M\u00ednima do Python 8.0+ 3.8+ 7.1+ 3.7+ 6.2 - 7.0 3.6+ 5.0 - 6.1 3.5+ 3.3 - 4.6 2.7, 3.4+"},{"location":"contributors/","title":"Contribuidores","text":""},{"location":"contributors/#contribuidores","title":"Contribuidores","text":"Pedro Fonseca Rodrigues de Sousa Ricardo Augusto Santos Vitor Pires Zini"},{"location":"examples/","title":"Exemplos","text":"<p>Agora que vimos a import\u00e2ncia da utiliza\u00e7\u00e3o de testes automatizados nos nossos programas e como prepar\u00e1-los a partir do framework PyTest. Vamos mergulhar em alguns exemplos:</p>"},{"location":"examples/#exemplo-da-conta-bancaria","title":"Exemplo da Conta Banc\u00e1ria","text":"<p>O primeiro exemplo remonta um programa que simula uma conta banc\u00e1ria e \u00e9 baseado nos testes de algumas funcionalidades da conta.</p> <p>&gt; Vamos dar uma olhada nas classes ContaBancaria e Cliente</p> ContaBancaria.pyCliente.py <pre><code>class Conta:\n\n    quantidade_contas = 0\n\n    @classmethod\n    def novo_id(cls):\n        cls.quantidade_contas += 1\n        return cls.quantidade_contas\n\n    @classmethod\n    def getQuantidadeContas(cls):\n        return cls.quantidade_contas\n\n    def __init__(self, cliente, saldoInicial):\n        self.cliente = cliente\n        self.id = self.novo_id()\n        self.saldo = saldoInicial\n\n    def getSaldo(self):\n        return self.saldo\n\n    def sacar(self, valor):\n        # Se houver saldo suficiente para o saque:\n        if ( self.saldo - valor &gt;= 0 ):\n            self.saldo -= valor\n            return True\n        else:\n            return False\n\n    def depositar(self, valor):\n        if ( valor &gt; 0 ):\n            self.saldo += valor\n            return True\n        else:\n            return False\n\n    def transferir(self, contaDestino, valor):\n        if ( valor &gt; 0 ):\n            self.sacar(valor)\n            contaDestino.depositar(valor)\n            return True\n        else:\n            return False\n</code></pre> <pre><code>class Cliente:\n\n    total_clientes = 0\n\n    @classmethod\n    def novo_id(cls):\n        cls.total_clientes += 1\n        return cls.total_clientes\n\n    @classmethod\n    def getTotalClientes(cls):\n        return cls.total_clientes\n\n    def __init__(self, nome):\n        self.nome = nome\n        self.id = self.novo_id()\n\n    def getNome(self):\n        return self.nome\n\n    def getId(self):\n        return self.id\n</code></pre> <p>&gt; Um cliente possui um nome e um id e m\u00e9todos de acesso aos seus atributos</p> <p>&gt; Uma conta banc\u00e1ria possui um n\u00famero identificador, um cliente associado e um saldo atual.</p> <p>Nosso objetivo \u00e9 criar testes automatizados para cuidar dos m\u00e9todos da nossa conta banc\u00e1ria.</p> <ol> <li>sacar()</li> <li>depositar()</li> <li>transferir()</li> </ol> <p>Dessa forma garantimos a integridade da classe ContaBancaria.</p> <p>Para isso, criamos uma classe de teste somente para as funcionalidades da conta banc\u00e1ria Segue o trecho de c\u00f3digo:</p> test_contaBancaria.py <pre><code>from banco.cliente import Cliente\nfrom banco.contaBancaria import Conta\n\n# o saque deve falhar!\ndef test_sacar_sem_saldo():\n    conta = Conta(Cliente(\"Jesimar\"), 0) # Criando uma conta com saldo inicial igual a 0\n    resultado = conta.sacar(1000) # Tentando sacar 1000 do saldo atual\n    assert resultado == False\n\n# o saque deve ocorrer com sucesso!\ndef test_sacar_com_saldo():\n    conta = Conta(Cliente(\"Jesimar\"), 1000) # Criando uma conta com saldo inicial igual a 1000\n    resultado = conta.sacar(500) # Sacando 500 do saldo atual\n    assert resultado == True\n\n# o dep\u00f3sito deve falhar!\ndef test_depositar_valor_negativo():\n    conta = Conta(Cliente(\"Jesimar\"), 0) # Criando uma conta com saldo inicial igual a 0\n    resultado = conta.depositar(-500) # Tentando depositar -500 no saldo atual\n    assert resultado == False\n\n# o dep\u00f3sito deve ocorrer com sucesso!\ndef test_depositar_valor_positivo():\n    conta = Conta(Cliente(\"Jesimar\"), 0) # Criando uma conta com saldo inicial igual a 0\n    resultado = conta.depositar(500) # Depositando um valor v\u00e1lido igual a 500\n    assert resultado == True\n\n# N\u00e3o deve conseguir sacar e n\u00e3o deve depositar na outra conta\ndef test_transferir_sem_saldo():\n    conta1 = Conta(Cliente(\"Raphael\"), 0) # Cliente 1 sem saldo inicial\n    conta2 = Conta(Cliente(\"Jesimar\"), 1000) # Cliente 2 com 1000 reais como saldo inicial\n\n    saldoConta1Antes = conta1.getSaldo() # Salvando o saldo da conta 1 antes da opera\u00e7\u00e3o\n    saldoConta2Antes = conta2.getSaldo() # Salvando o saldo da conta 2 antes da opera\u00e7\u00e3o\n\n    resultado = conta1.transferir(conta2, 2000) # Cliente 1 tenta transferir 2000 reais\n\n    saldoConta1Depois = conta1.getSaldo() # Salvando o saldo da conta 1 ap\u00f3s da opera\u00e7\u00e3o\n    saldoConta2Depois = conta2.getSaldo() # Salvando o saldo da conta 2 ap\u00f3s da opera\u00e7\u00e3o\n\n    # O Saldo das contas antes e depois deve ser o mesmo, pois a transfer\u00eancia n\u00e3o deve ocorrer.\n    assert (resultado == False and saldoConta1Antes == saldoConta1Depois and saldoConta2Antes == saldoConta2Depois)\n</code></pre> <p>Podemos observar acima que foram criados dois m\u00e9todos para testar as funcionalidades de saque e dois para dep\u00f3sito:</p> <p>Falhas</p> <p>Sacar sem saldo e Depositar um valor negativo!</p> <p>\u00caxitos</p> <p>Sacar com saldo e Depositar um valor positivo!</p> <p>J\u00e1 o teste de transfer\u00eancia \u00e9 mais interessante. Ele envolve utilizar os outros m\u00e9todos que j\u00e1 possuem seus pr\u00f3prios testes, sacar e depositar e a sua intera\u00e7\u00e3o. Ao analisar o c\u00f3digo do teste de transfer\u00eancia, \u00e9 poss\u00edvel perceber que h\u00e1 uma l\u00f3gica por traz dessa opera\u00e7\u00e3o que n\u00e3o pode ser ignorada. Essa l\u00f3gica consiste no seguinte fato:</p> <p>&gt; Caso a conta de origem da trasfer\u00eancia n\u00e3o possua saldo suficiente para realizar a opera\u00e7\u00e3o, o valor n\u00e3o deve ser sacado. </p> <p>Isso j\u00e1 nos foi garantido se nosso teste de saque foi bem sucedido. Ao final da opera\u00e7\u00e3o, \u00e9 evidente que o valor de transfer\u00eancia n\u00e3o deve ser decrementado do saldo da conta de origem e posteriormente incrementado no saldo da conta de destino, e \u00e9 justamente isso que nosso teste verifica.</p> <p>Dessa forma, vamos realizar os testes e verificar o que o PyTest nos informa:</p> <pre><code>=============================================================== test session starts ================================================================\nplatform win32 -- Python 3.12.4, pytest-8.3.2, pluggy-1.5.0 -- C:\\Users\\vitor\\Documentos\\trabalhoWeb\\pyTEST\\venv\\Scripts\\python.exe\ncachedir: .pytest_cache\nrootdir: C:\\Users\\vitor\\Documentos\\trabalhoWeb\\pyTEST\\banco\\tests\ncollected 5 items                                                                                                                                    \n\ntest_contaBancaria.py::test_sacar_sem_saldo PASSED                                                                                            [ 20%] \ntest_contaBancaria.py::test_sacar_com_saldo PASSED                                                                                            [ 40%] \ntest_contaBancaria.py::test_depositar_valor_negativo PASSED                                                                                   [ 60%] \ntest_contaBancaria.py::test_depositar_valor_positivo PASSED                                                                                   [ 80%] \ntest_contaBancaria.py::test_transferir_sem_saldo FAILED                                                                                       [100%]\n\n===================================================================== FAILURES ===================================================================== \n</code></pre> <p>Podemos observar que o \u00faltimo teste falhou, mas j\u00e1 analisamos o teste e n\u00e3o parece haver nada de errado com ele. O problema s\u00f3 pode estar na implementa\u00e7\u00e3o da transfer\u00eancia.</p> <p>Nota</p> <p>Percebemos atrav\u00e9s desse exemplo que ao realizar um teste e analisar qual o comportamento esperado de um m\u00e9todo e se esse comportamento foi respeitado pode nos fazer perceber algum erro na implementa\u00e7\u00e3o do m\u00e9todo. Mais uma vantagem de preparar testes para seu sistema.</p> Transferir ErradoTranferir Correto <pre><code>def transferir(self, contaDestino, valor):\n    if ( valor &gt; 0 ):\n        self.sacar(valor)# AQUI EST\u00c1 O PROBLEMA\n        contaDestino.depositar(valor)# O DEP\u00d3SITO OCORRE MESMO SE O SAQUE FALHAR\n        return True\n    else:\n        return False\n</code></pre> <pre><code>def transferirCorreto(self, contaDestino, valor):\n    if ( valor &gt; 0 ):\n        if ( self.sacar(valor) ): # SE CONSEGUIR SACAR\n            contaDestino.depositar(valor) # REALIZA O DEP\u00d3SITO\n            return True\n    return False\n</code></pre> <p>Agora sim!!</p> <p>&gt; Vamos executar o comando pytest novamente</p> <pre><code>=============================================================== test session starts ================================================================\nplatform win32 -- Python 3.12.4, pytest-8.3.2, pluggy-1.5.0 -- C:\\Users\\vitor\\Documentos\\trabalhoWeb\\pyTEST\\venv\\Scripts\\python.exe\ncachedir: .pytest_cache\nrootdir: C:\\Users\\vitor\\Documentos\\trabalhoWeb\\pyTEST\\banco\\tests\ncollected 5 items                                                                                                                                    \n\ntest_contaBancaria.py::test_sacar_sem_saldo PASSED                                                                                            [ 20%]\ntest_contaBancaria.py::test_sacar_com_saldo PASSED                                                                                            [ 40%] \ntest_contaBancaria.py::test_depositar_valor_negativo PASSED                                                                                   [ 60%] \ntest_contaBancaria.py::test_depositar_valor_positivo PASSED                                                                                   [ 80%] \ntest_contaBancaria.py::test_transferir_sem_saldo PASSED                                                                                       [100%] \n\n================================================================ 5 passed in 0.02s ================================================================= \n</code></pre> <p>Todos os nossos testes foram aprovados e podemos seguir com o desenvolvimento do nosso sistema de contas banc\u00e1rias. Lembrando que de agora em diante, para verificarmos se nossos m\u00e9todos continuam funcionando corretamente, basta executar o comando pytest e verificar o resultado. Nossa vida ficou muito mais f\u00e1cil!</p>"},{"location":"howToUse/","title":"Uso do PyTest","text":"<p>O PyTest oferece diversas op\u00e7\u00f5es para executar testes no seu projeto Python. Abaixo, est\u00e3o alguns dos principais comandos e funcionalidades para rodar seus testes.</p>"},{"location":"howToUse/#comandos-de-ajuda","title":"Comandos de ajuda","text":"<p>Obter ajuda sobre a vers\u00e3o, nomes de op\u00e7\u00f5es e vari\u00e1veis de ambiente</p> <pre><code>pytest --version # mostra de onde o pytest foi importado\npytest --fixtures # exibe os argumentos de fun\u00e7\u00e3o embutidos dispon\u00edveis\npytest -h ou pytest --help # exibe ajuda sobre op\u00e7\u00f5es de linha de comando\n</code></pre>"},{"location":"howToUse/#executando-testes","title":"Executando Testes","text":"<p>Para executar todos os testes, utilize:</p> <p>Executando testes em um arquivo</p> <pre><code>pytest test_arquivo.py\n</code></pre> <p>Executando testes em um diret\u00f3rio</p> <pre><code>pytest test_diretorio.py\n</code></pre> <p>pytest -k 'MinhaClasse e n\u00e3o metodo'</p> <p>Nota</p> <p>Isso executar\u00e1 testes cujos nomes correspondam \u00e0 express\u00e3o de string fornecida (ignorando mai\u00fasculas e min\u00fasculas), que pode incluir operadores Python que utilizam nomes de arquivos, nomes de classes e nomes de fun\u00e7\u00f5es como vari\u00e1veis. O exemplo acima executar\u00e1 TestMinhaClasse.test_qualquer, mas n\u00e3o TestMinhaClasse.test_metodo_simples. Use \"\" em vez de '' na express\u00e3o ao executar isso no Windows.</p>"},{"location":"howToUse/#executando-testes-por-argumentos-de-coleta","title":"Executando testes por argumentos de coleta","text":"<p>Passe o nome do arquivo do m\u00f3dulo relativo ao diret\u00f3rio de trabalho, seguido por especificadores como o nome da classe e o nome da fun\u00e7\u00e3o separados por caracteres ::, e par\u00e2metros de parametriza\u00e7\u00e3o entre colchetes [].</p> <p>Para executar um teste espec\u00edfico dentro de um m\u00f3dulo: <pre><code>pytest tests/test_arquivo.py::test_funcao\n</code></pre></p> <p>Para executar todos os testes em uma classe: <pre><code>pytest tests/test_arquivo.py::TestClasse\n</code></pre></p> <p>Especificando um m\u00e9todo de teste espec\u00edfico: <pre><code>pytest tests/test_arquivo.py::TestClasse::test_metodo\n</code></pre></p> <p>specificando uma parametriza\u00e7\u00e3o espec\u00edfica de um teste: <pre><code>pytest tests/test_arquivo.py::test_funcao[x1,y2]\n</code></pre></p> <p>Controlando o tempo de dura\u00e7\u00e3o da execu\u00e7\u00e3o do teste</p> <p>Para obter uma lista dos 10 testes mais lentos com dura\u00e7\u00e3o superior a 1,0s: <pre><code>pytest --durations=10 --durations-min=1.0\n</code></pre></p> <p>Nota</p> <p>Por padr\u00e3o, o pytest n\u00e3o mostrar\u00e1 as dura\u00e7\u00f5es dos testes que s\u00e3o muito pequenas (&lt;0,005s), a menos que o par\u00e2metro \"-vv\" seja adicionado na linha de comando.</p>"},{"location":"howToUse/#chamando-pytest-diretamente-do-codigo","title":"Chamando Pytest diretamente do c\u00f3digo","text":"<p>Voc\u00ea pode invocar o pytest diretamente a partir de c\u00f3digo Python: <pre><code>retcode = pytest.main()\n</code></pre> Isso age como se voc\u00ea estivesse chamando \u201cpytest\u201d a partir da linha de comando. Ele n\u00e3o levantar\u00e1 SystemExit, mas retornar\u00e1 o c\u00f3digo de sa\u00edda. Se voc\u00ea n\u00e3o passar nenhum argumento, o main ler\u00e1 os argumentos a partir dos argumentos da linha de comando do processo (\"sys.argv\"), o que pode n\u00e3o ser desej\u00e1vel. Voc\u00ea pode passar op\u00e7\u00f5es e argumentos explicitamente: <pre><code>retcode = pytest.main([\"-x\", \"meudiretorio\"])\n</code></pre></p>"},{"location":"howToUse/#plugins","title":"Plugins","text":"<p>Voc\u00ea tamb\u00e9m pode utilizar plugins feitos por outras pessoas nos testes, ou at\u00e9 mesmo fazer seu pr\u00f3prio plugin.</p> <p>Para instalar e desistalar plugins utilize os seguintes comandos:</p> <p><pre><code>pip install pytest-NAME\npip uninstall pytest-NAME\n</code></pre> Se um plugin \u00e9 instalado, o pytest automaticamente acha e faz a integra\u00e7\u00e3o, n\u00e3o h\u00e1 necessidade de ativ\u00e1-los.</p> <p>Aqui est\u00e1 alguns plugins populares:</p> <ul> <li> <p>pytest-django: Escreve testes para aplicativos Django, utilizando a integra\u00e7\u00e3o com pytest.</p> </li> <li> <p>pytest-cov: Relat\u00f3rios de cobertura de c\u00f3digo, compat\u00edvel com testes distribu\u00eddos.</p> </li> <li> <p>pytest-instafail: Relata falhas enquanto o teste est\u00e1 sendo executado.</p> </li> <li> <p>pytest-timeout: Define limites de tempo para testes com base em marca\u00e7\u00f5es de fun\u00e7\u00f5es ou defini\u00e7\u00f5es globais.</p> </li> <li> <p>pytest-pep8: Uma op\u00e7\u00e3o \"--pep8\" para habilitar a verifica\u00e7\u00e3o de conformidade com o PEP8.</p> </li> </ul>"}]}